#scope_module


manage_imports :: true;
#if OS == .WINDOWS  downloaded_modules_folder :: "c:\\jai\\modules_downloaded";
else                downloaded_modules_folder :: "~/jai/modules_downloaded";

check_for_reallocatable_pointers :: Option.OFF;
log_messages                     :: false;


Option :: enum {
    OFF;
    WARNING;
    ERROR;
}


#import "Basic";
#import "Compiler";


report :: (node: *Code_Node, message: string, report_option: Option) {
    if report_option == {
        case .WARNING;  compiler_report(message, make_location(node), .WARNING);
        case .ERROR;    compiler_report(message, make_location(node), .ERROR);
    }
}


has_note :: (declaration: *Code_Declaration, note: string) -> bool {
    for declaration.notes  if it.text == note  return true;
    return false;
}


// @Note `log` is generated by the commented-out code below

log :: (node: *Code_Node) {
    ctx := context;
    push_context ctx {
        format := *context.print_style.default_format_struct;
        format.use_long_form_if_more_than_this_many_members = 0;
        format.use_newlines_if_long_form = true;

        if node.kind == {
            case .BLOCK;  print("%\n", <<cast(*Code_Block)node);
            case .LITERAL;  print("%\n", <<cast(*Code_Literal)node);
            case .IDENT;  print("%\n", <<cast(*Code_Ident)node);
            case .UNARY_OPERATOR;  print("%\n", <<cast(*Code_Unary_Operator)node);
            case .BINARY_OPERATOR;  print("%\n", <<cast(*Code_Binary_Operator)node);
            case .PROCEDURE_BODY;  print("%\n", <<cast(*Code_Procedure_Body)node);
            case .PROCEDURE_CALL;  print("%\n", <<cast(*Code_Procedure_Call)node);
            case .CONTEXT;  print("%\n", <<cast(*Code_Context)node);
            case .WHILE;  print("%\n", <<cast(*Code_While)node);
            case .IF;  print("%\n", <<cast(*Code_If)node);
            case .LOOP_CONTROL;  print("%\n", <<cast(*Code_Loop_Control)node);
            case .CASE;  print("%\n", <<cast(*Code_Case)node);
            case .RETURN;  print("%\n", <<cast(*Code_Return)node);
            case .FOR;  print("%\n", <<cast(*Code_For)node);
            case .TYPE_DEFINITION;  print("%\n", <<cast(*Code_Type_Definition)node);
            case .TYPE_INSTANTIATION;  print("%\n", <<cast(*Code_Type_Instantiation)node);
            case .ENUM;  print("%\n", <<cast(*Code_Enum)node);
            case .PROCEDURE_HEADER;  print("%\n", <<cast(*Code_Procedure_Header)node);
            case .STRUCT;  print("%\n", <<cast(*Code_Struct)node);
            case .COMMA_SEPARATED_ARGUMENTS;  print("%\n", <<cast(*Code_Comma_Separated_Arguments)node);
            case .EXTRACT;  print("%\n", <<cast(*Code_Extract)node);
            case .SEQUENCE;  print("%\n", <<cast(*Code_Sequence)node);
            case .MAKE_VARARGS;  print("%\n", <<cast(*Code_Make_Varargs)node);
            case .DECLARATION;  print("%\n", <<cast(*Code_Declaration)node);
            case .CAST;  print("%\n", <<cast(*Code_Cast)node);
            case .DIRECTIVE_IMPORT;  print("%\n", <<cast(*Code_Directive_Import)node);
            case .DIRECTIVE_THROUGH;  print("%\n", <<cast(*Code_Directive_Through)node);
            case .DIRECTIVE_RUN;  print("%\n", <<cast(*Code_Directive_Run)node);
            case .DIRECTIVE_CODE;  print("%\n", <<cast(*Code_Directive_Code)node);
            case .DIRECTIVE_POKE_NAME;  print("%\n", <<cast(*Code_Directive_Poke_Name)node);
            case .ASM;  print("%\n", <<cast(*Code_Asm)node);
            case .DIRECTIVE_BAKE;  print("%\n", <<cast(*Code_Directive_Bake)node);
            case .DIRECTIVE_MODIFY;  print("%\n", <<cast(*Code_Directive_Modify)node);
            case .DIRECTIVE_FOREIGN_LIBRARY;  print("%\n", <<cast(*Code_Directive_Foreign_Library)node);
            case .SIZE_OR_TYPE_INFO;  print("%\n", <<cast(*Code_Size_Or_Type_Info)node);
            case .PUSH_CONTEXT;  print("%\n", <<cast(*Code_Push_Context)node);
            case .NOTE;  print("%\n", <<cast(*Code_Note)node);
            case .DIRECTIVE_SCOPE;  print("%\n", <<cast(*Code_Directive_Scope)node);
            case .DIRECTIVE_STATIC_IF;  print("%\n", <<cast(*Code_Directive_Static_If)node);
            case .DIRECTIVE_LOCATION;  print("%\n", <<cast(*Code_Directive_Location)node);
            case .COMPOUND_DECLARATION;  print("%\n", <<cast(*Code_Compound_Declaration)node);
            case .DEFER;  print("%\n", <<cast(*Code_Defer)node);
            case .USING;  print("%\n", <<cast(*Code_Using)node);
            case .PLACEHOLDER;  print("%\n", <<cast(*Code_Placeholder)node);
            case .DIRECTIVE_INSERT;  print("%\n", <<cast(*Code_Directive_Insert)node);
        }
    }
}

/* This generates the above `log` procedure
#insert -> string {
    reflection :: #import "Reflection";
    builder : String_Builder;
    append(*builder, #string __jai
        log :: (node: *Code_Node) {
            format := *context.print_style.default_format_struct;
            format.use_long_form_if_more_than_this_many_members = 0;
            format.use_newlines_if_long_form = true;

            if node.kind == {
    __jai);

    for 0 .. 51 {
        enum_value := cast(Code_Node.Kind)it;
        if enum_value == {
            case .DIRECTIVE_ADD_CONTEXT; #through;
            case .DIRECTIVE_ALIGN; #through;
            case .DIRECTIVE_PLACE; #through;
            case .DIRECTIVE_LOAD; #through;
            case .DIRECTIVE_THIS; #through;
            case .REMOVE; #through;
            case .UNINITIALIZED;
            continue;
        }
        enum_name := reflection.get_enum_name(enum_value);
        type_name := sprint("Code_%", enum_name);
        for 5 .. type_name.count - 1
            if type_name[it - 1] != #char "_"
                type_name[it] = to_lower(type_name[it]);
        print_to_builder(*builder, #string __jai
                case .%1;  print("%%\n", <<cast(*%2)node);
        __jai, enum_name, type_name);
    }

    append(*builder, #string __jai
            }
        }
    __jai);

    return builder_to_string(*builder);
}
*/


// @Note This for_expansion is intended to walk the "navigable" nodes under-and-including the
//       root node.  It doesn't include nodes adjacent or above, it is only intended to get the
//       local nodes.  For declarations, headers, etc you need to get them yourself.
// @TODO Even so, we've probably screwed up and looped over the same nodes more than once...
//       or failed to follow a node we should have...

for_expansion :: (root_node: *Code_Node, body: Code, flags: For_Flags) #expand {
    #assert(flags & .REVERSE == 0);

    `it_index := -1;
    #if flags & .POINTER
        `it : *Code_Node;
    else
        `it : Code_Node;

    nodes : [..] *Code_Node;
    add :: (node: *Code_Node) #expand { if node  array_add(*`nodes, node); }
    add(root_node);
    defer array_free(nodes);

    while nodes.count {
        node := pop(*nodes);

        it_index += 1;
        #if flags & .POINTER
            it = node;
        else
            it = <<node;

        #insert body;

        if node.kind == {
            case .BLOCK;
            node_block := <<cast(*Code_Block)node;
            for node_block.statements  add(it);

            case .UNARY_OPERATOR;
            node_unary_operator := <<cast(*Code_Unary_Operator)node;
            add(node_unary_operator.subexpression);

            case .BINARY_OPERATOR;
            node_binary_operator := <<cast(*Code_Binary_Operator)node;
            add(node_binary_operator.left);
            add(node_binary_operator.right);

            case .PROCEDURE_BODY;
            node_procedure_body := <<cast(*Code_Procedure_Body)node;
            add(node_procedure_body.block);
            //node_procedure_body.header;

            case .PROCEDURE_CALL;
            node_procedure_call := <<cast(*Code_Procedure_Call)node;
            for node_procedure_call.arguments_sorted  add(it);

            case .WHILE;
            node_while := <<cast(*Code_While)node;
            add(node_while.condition);
            add(node_while.block);

            case .IF;
            node_if := <<cast(*Code_If)node;
            add(node_if.condition);
            add(node_if.then_block);
            add(node_if.else_block);

            case .CASE;
            node_case := <<cast(*Code_Case)node;
            add(node_case.condition);
            add(node_case.then_block);

            case .RETURN;
            node_return := <<cast(*Code_Return)node;
            for node_return.arguments_sorted  add(it);

            case .FOR;
            node_for := <<cast(*Code_For)node;
            add(node_for.iteration_expression);
            add(node_for.iteration_expression_right);
            add(node_for.block);
            add(node_for.want_pointer_expression);
            add(node_for.want_reverse_expression);

            case .TYPE_INSTANTIATION;
            node_type_instantiation := <<cast(*Code_Type_Instantiation)node;
            add(node_type_instantiation.type_valued_expression);
            add(node_type_instantiation.array_dimension);

            case .ENUM;
            node_enum := <<cast(*Code_Enum)node;
            add(node_enum.block);

            case .PROCEDURE_HEADER;
            node_procedure_header := <<cast(*Code_Procedure_Header)node;
            add(node_procedure_header.constants_block);
            for node_procedure_header.arguments  add(it);
            for node_procedure_header.modify_directives  add(it);
            for node_procedure_header.notes  add(it);
            for node_procedure_header.returns  add(it);

            case .STRUCT;
            node_struct := <<cast(*Code_Struct)node;
            add(node_struct.block);
            add(node_struct.constants_block);
            for node_struct.notes  add(it);

            case .COMMA_SEPARATED_ARGUMENTS;
            node_comma_separated_arguments := <<cast(*Code_Comma_Separated_Arguments)node;
            for node_comma_separated_arguments.expressions add(it);

            case .EXTRACT;
            node_extract := <<cast(*Code_Extract)node;
            add(node_extract.from);

            case .SEQUENCE;
            node_sequence := <<cast(*Code_Sequence)node;
            for node_sequence.expressions  add(it);
            //expression_i_replaced?

            case .MAKE_VARARGS;
            node_make_varargs := <<cast(*Code_Make_Varargs)node;
            for node_make_varargs.expressions  add(it);

            case .DECLARATION;
            node_declaration := <<cast(*Code_Declaration)node;
            add(node_declaration.type_inst);
            add(node_declaration.expression);
            add(node_declaration.alignment_expression);
            for node_declaration.notes  add(it);

            case .CAST;
            node_cast := <<cast(*Code_Cast)node;
            add(node_cast.expression);

            case .DIRECTIVE_IMPORT;
            node_directive_import := <<cast(*Code_Directive_Import)node;
            add(node_directive_import.module_parameters_call);
            add(node_directive_import.program_parameters_call);

            case .DIRECTIVE_RUN;
            node_directive_run := <<cast(*Code_Directive_Run)node;
            add(node_directive_run.procedure);

            case .DIRECTIVE_CODE;
            node_directive_code := <<cast(*Code_Directive_Code)node;
            add(node_directive_code.expression);

            case .DIRECTIVE_BAKE;
            node_directive_bake := <<cast(*Code_Directive_Bake)node;
            add(node_directive_bake.procedure_call);

            case .DIRECTIVE_MODIFY;
            node_directive_modify := <<cast(*Code_Directive_Modify)node;
            add(node_directive_modify.block);

            case .SIZE_OR_TYPE_INFO;
            node_size_or_type_info := <<cast(*Code_Size_Or_Type_Info)node;
            add(node_size_or_type_info.type_of_expression);

            case .PUSH_CONTEXT;
            node_push_context := <<cast(*Code_Push_Context)node;
            add(node_push_context.to_push);
            add(node_push_context.block);

            case .DIRECTIVE_STATIC_IF;
            node_directive_static_if := <<cast(*Code_Directive_Static_If)node;
            add(node_directive_static_if.condition);
            add(node_directive_static_if.then_block);
            add(node_directive_static_if.else_block);

            case .DIRECTIVE_LOCATION;
            node_directive_location := <<cast(*Code_Directive_Location)node;
            add(node_directive_location.expression);

            case .COMPOUND_DECLARATION;
            node_compound_declaration := <<cast(*Code_Compound_Declaration)node;
            add(node_compound_declaration.comma_separated_assignment);
            add(node_compound_declaration.declaration_properties);
            add(node_compound_declaration.alignment_expression);
            for node_compound_declaration.notes  add(it);

            case .DEFER;
            node_defer := <<cast(*Code_Defer)node;
            add(node_defer.block);

            case .USING;
            node_using := <<cast(*Code_Using)node;
            add(node_using.expression);

            case .DIRECTIVE_INSERT;
            node_directive_insert := <<cast(*Code_Directive_Insert)node;
            add(node_directive_insert.expression);


            case .LITERAL; #through;
            //node_literal := <<cast(*Code_Literal)node;
            //if node_literal.value_type == .STRUCT
            //|| node_literal.value_type == .ARRAY
            //|| node_literal.value_type == .POINTER
            //    add(cast(*Code_Node)node_literal.pointer_literal_info); // is a union, so just pick one

            case .IDENT; #through;
            //node_ident := <<cast(*Code_Ident)node;
            // resolved_declaration?

            case .ASM; #through;
            case .CONTEXT; #through;
            case .DIRECTIVE_ADD_CONTEXT; #through;
            case .DIRECTIVE_ALIGN; #through;
            case .DIRECTIVE_FOREIGN_LIBRARY; #through;
            case .DIRECTIVE_LOAD; #through;
            case .DIRECTIVE_PLACE; #through;
            case .DIRECTIVE_POKE_NAME;
            case .DIRECTIVE_SCOPE; #through;
            case .DIRECTIVE_THIS; #through;
            case .DIRECTIVE_THROUGH; #through;
            case .LOOP_CONTROL; #through;
            case .NOTE; #through;
            case .PLACEHOLDER; #through;
            case .REMOVE; #through;
            case .TYPE_DEFINITION; #through;
            case .UNINITIALIZED;
            continue;
        }
    }
}


#scope_export


check_message :: (message: *Message) {
    if !message  return;

    #if manage_imports {
        #load "check_imports.jai";
        check_imports(message);
    }

    #if check_for_reallocatable_pointers  {
        #load "check_reallocatable_pointers.jai";
        check_reallocatable_pointers(message);
    }

    #load "log_messages.jai";
    #if log_messages {
        log_message(message);
    }
}
